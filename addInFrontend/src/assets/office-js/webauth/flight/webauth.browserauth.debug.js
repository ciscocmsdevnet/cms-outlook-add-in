var BrowserAuth =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./packages/Microsoft.Office.WebAuth.BrowserAuth/lib/api.js":
/*!******************************************************************!*\
  !*** ./packages/Microsoft.Office.WebAuth.BrowserAuth/lib/api.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.logUserAction = logUserAction;\r\nexports.logActivity = logActivity;\r\nexports.sendTelemetryEvent = sendTelemetryEvent;\r\nexports.sendActivityEvent = sendActivityEvent;\r\nexports.sendOtelEvent = sendOtelEvent;\r\nexports.sendUserActionEvent = sendUserActionEvent;\r\nexports.addNamespaceMapping = addNamespaceMapping;\r\nexports.setEnabledState = setEnabledState;\r\nexports.shutdown = shutdown;\r\nexports.registerEventHandler = registerEventHandler;\r\n\r\nvar telemetryEnabled = false;\r\nvar events = [];\r\nvar eventHandler;\r\nvar numberOfDroppedEvents = 0;\r\nvar maxQueueSize = 20000;\r\nvar unknownStr = 'Unknown'; // Primary consumer public API\r\n\r\n// ========================================================================================================================\r\n// Call LogUserAction for logging a user action to Otel.\r\n// This is similar to the bSqm actions that used to be logged earlier (deprecated now).\r\n// Make sure you read the documentation below for userActionName and the Kusto table name implications.\r\n// userActionName: Name of the user action, this should come from your app's commands,\r\n//     for example: OneNoteCommands in office-online-ui\\packages\\onenote-online-ux\\src\\store\\OneNoteCommands.ts (https://office.visualstudio.com/OC/_git/office-online-ui?path=%2Fpackages%2Fonenote-online-ux%2Fsrc%2Fstore%2FOneNoteCommands.ts&version=GBmaster)\r\n//     Note that the userActionName will be the name of your table in Aria Kusto. So if 'ABC' is passed in for userActionName, the table in Kusto will be called Office_OneNote_Online_UserAction_ABC (or generically speaking Office_{AppName}_Online_UserAction_ABC )\r\n//     Look at Kusto connection https://kusto.aria.microsoft.com and databases Office Word Online or Office OneNote Online, etc. and look at *UserAction* tables.\r\n// success: Status of the user action (success is true, failure is false).\r\n// parentNameStr: parent surface of the user action (example, tabView, tabHelp, Layout, etc).\r\n// inputMethod: how the user action was performed (for example, via keyboard, or mouse, touch, etc.)\r\n//             See the enum in /packages/app-commanding-ui/src/UISurfaces/controls/InputMethod.ts\r\n//             Pass in this param as:  InputMethod.Keyboard.toString() instead of passing in \"Keyboard\"\r\n// uiLocation: the surface where the user action was initiated from (example, ribbon, FileMenu, TellMe, etc).\r\n//             See enum in /packages/app-commanding-ui/src/UISurfaces/controls/UILocation.ts\r\n//             Pass in this param as:  UILocation.SingleLineRibbon.toString() instead of passing in \"SingleLineRibbon\"\r\n// durationMsec: the time taken by the action (if relevant to the action)\r\n// dataFieldArr: These are custom fields that you may want to add for your user action.\r\n//               Example: InsertTable action may log custom data fields such as rowSize and colSize of the table inserted.\r\n//                      Or in Excel, a cell related action may log the x and y coordinates of the cell.\r\n// Note that things such as sessionID, data center, etc will be added to all user action logs.\r\nfunction logUserAction(userActionName, success, parentNameStr, inputMethod, uiLocation, durationMsec, dataFieldArr) {\r\n  if (success === void 0) {\r\n    success = true;\r\n  }\r\n\r\n  if (parentNameStr === void 0) {\r\n    parentNameStr = unknownStr;\r\n  }\r\n\r\n  if (inputMethod === void 0) {\r\n    inputMethod = unknownStr;\r\n  }\r\n\r\n  if (uiLocation === void 0) {\r\n    uiLocation = unknownStr;\r\n  }\r\n\r\n  if (durationMsec === void 0) {\r\n    durationMsec = 0;\r\n  }\r\n\r\n  if (dataFieldArr === void 0) {\r\n    dataFieldArr = [];\r\n  }\r\n\r\n  // passing null for 'name' field, which is the event table name. We will determine that in sendUserAction in full\\api.ts as there we know what app we are, and hence what the event table name is\r\n  sendUserActionEvent({\r\n    name: null,\r\n    actionName: userActionName,\r\n    commandSurface: uiLocation,\r\n    parentName: parentNameStr,\r\n    triggerMethod: inputMethod,\r\n    durationMs: durationMsec,\r\n    succeeded: success,\r\n    dataFields: dataFieldArr\r\n  });\r\n}\r\n\r\n// Call logActivity for logging an activity to Otel.\r\n// This will be logged under Office {App} Online Data tenant\r\n// For example, if your activity name is \"ABC\",\r\n// it will go to a table called \"Office_Word_Online_Data_Activity_ABC\" for Word or \"Office_OneNote_Online_Data_Activity_ABC\" for OneNote.\r\n// activityName: name of activity being logged\r\n// success: Status of the activity (success is true, failure is false).\r\n// durationMsec: the time taken by the action (if relevant to the action)\r\n// dataFieldArr: These are custom fields that you may want to add for your activity, and will be added as columns to the activity table.\r\n//               Example: dataFields has typingSpeedPerSec (integer) and dayOfWeek (string) in it, the activity table for this particular activity will contain these two custom fields.\r\n// Note that things such as sessionID, data center, etc will be added to all user action logs.\r\nfunction logActivity(activityName, success, durationMsec, dataFieldArr) {\r\n  if (success === void 0) {\r\n    success = true;\r\n  }\r\n\r\n  if (durationMsec === void 0) {\r\n    durationMsec = 0;\r\n  }\r\n\r\n  if (dataFieldArr === void 0) {\r\n    dataFieldArr = [];\r\n  }\r\n\r\n  sendActivityEvent({\r\n    name: activityName,\r\n    succeeded: success,\r\n    durationMs: durationMsec,\r\n    dataFields: dataFieldArr\r\n  });\r\n}\r\n\r\nfunction sendTelemetryEvent(event) {\r\n  raiseEvent({\r\n    kind: 'event',\r\n    event: event,\r\n    timestamp: new Date().getTime()\r\n  });\r\n}\r\n\r\nfunction sendActivityEvent(event) {\r\n  raiseEvent({\r\n    kind: 'activity',\r\n    event: event,\r\n    timestamp: new Date().getTime()\r\n  });\r\n}\r\n\r\nfunction sendOtelEvent(event) {\r\n  raiseEvent({\r\n    kind: 'otel',\r\n    event: event\r\n  });\r\n}\r\n\r\nfunction sendUserActionEvent(event) {\r\n  raiseEvent({\r\n    kind: 'action',\r\n    event: event,\r\n    timestamp: new Date().getTime()\r\n  });\r\n}\r\n\r\nfunction addNamespaceMapping(namespace, ariaTenantToken) {\r\n  raiseEvent({\r\n    kind: 'addNamespaceMapping',\r\n    namespace: namespace,\r\n    ariaTenantToken: ariaTenantToken\r\n  });\r\n}\r\n\r\nfunction setEnabledState(enabled) {\r\n  telemetryEnabled = enabled; // If the caller disables the queue, be sure to drop all of the outstanding events.\r\n  // This can happen in cases where the slice with event processor functionality failed to load.\r\n\r\n  if (!telemetryEnabled) {\r\n    events = [];\r\n  }\r\n}\r\n\r\nfunction shutdown() {\r\n  raiseEvent({\r\n    kind: 'shutdown'\r\n  });\r\n  return events.length + numberOfDroppedEvents;\r\n}\r\n\r\nfunction registerEventHandler(handler) {\r\n  eventHandler = handler; // Then go through the queue and process the events in the order in which they were received\r\n  // VSO.2533164: Push batch event processing to otelFull and add a lightweight queue\r\n\r\n  events.forEach(function (event) {\r\n    return raiseEvent(event);\r\n  });\r\n  events = [];\r\n}\r\n\r\nfunction raiseEvent(event) {\r\n  if (!telemetryEnabled) {\r\n    return;\r\n  }\r\n\r\n  if (eventHandler) {\r\n    eventHandler(event);\r\n  } else {\r\n    if (events.length <= maxQueueSize) {\r\n      events.push(event);\r\n    } else {\r\n      numberOfDroppedEvents += 1;\r\n    }\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://BrowserAuth/./packages/Microsoft.Office.WebAuth.BrowserAuth/lib/api.js?");

/***/ }),

/***/ "./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/BrowserAuth.ts":
/*!******************************************************************************!*\
  !*** ./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/BrowserAuth.ts ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Copyright (c) Microsoft. All rights reserved.\r\n */\r\n/// <reference path=\"./Definitions/IBrowserAuthConfig.d.ts\" />\r\n/// <reference path=\"./Definitions/IBrowserAuthResult.d.ts\" />\r\n// Above references are needed for ts-node\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Constants_1 = __webpack_require__(/*! ./Utils/Constants */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/Constants.ts\");\r\nexports.Constants = Constants_1.Constants;\r\nvar ExtractUtils_1 = __webpack_require__(/*! ./Utils/ExtractUtils */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ExtractUtils.ts\");\r\nexports.ExtractUtils = ExtractUtils_1.ExtractUtils;\r\nvar LoggingUtils_1 = __webpack_require__(/*! ./Utils/LoggingUtils */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/LoggingUtils.ts\");\r\nexports.LoggingUtils = LoggingUtils_1.LoggingUtils;\r\nvar ValidateUtils_1 = __webpack_require__(/*! ./Utils/ValidateUtils */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ValidateUtils.ts\");\r\nexports.ValidateUtils = ValidateUtils_1.ValidateUtils;\r\nvar TimerUtils_1 = __webpack_require__(/*! ./Utils/TimerUtils */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/TimerUtils.ts\");\r\n// This is the aria token used for Otel telemetry event ingestion.\r\nvar api_js_1 = __webpack_require__(/*! ../lib/api.js */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/lib/api.js\");\r\napi_js_1.addNamespaceMapping('Office.Identity.WebAuth.BrowserAuth', '5c65bbc4edbf480d9637ace04d62bd98-12844893-8ab9-4dde-b850-5612cb12e0f2-7822');\r\nvar msalInstance;\r\nexports.msalInstance = msalInstance;\r\nvar applications;\r\nexports.applications = applications;\r\nvar authConfig;\r\n/**\r\n * Load auth code module\r\n * @param configurations - auth configs\r\n * @param correlationId - the correlation ID exists under the caller's context, the same correlation ID will passed on to MSAL.js for unified experience\r\n * @returns the {@link IBrowserAuthLoadResult} object\r\n */\r\nfunction Load(configurations, correlationId) {\r\n    var timerClock = TimerUtils_1.TimerUtils.timer();\r\n    authConfig = configurations;\r\n    if (authConfig.enableConsoleLogging) {\r\n        // Turn on if explicitly authConfig.enableConsoleLogging is true\r\n        LoggingUtils_1.LoggingUtils.enableConsoleLogging = authConfig.enableConsoleLogging;\r\n    }\r\n    if (authConfig.enableUpnCheck) {\r\n        // Turn on if explicitly authConfig.enableUpnCheck is true\r\n        ValidateUtils_1.ValidateUtils.enableUpnCheck = authConfig.enableUpnCheck;\r\n    }\r\n    // Implicitly swap login.windows.net to login.microsoftonline.com\r\n    if (authConfig.authority) {\r\n        authConfig.authority = authConfig.authority.replace(Constants_1.Constants.Authority.ProdLegacy, Constants_1.Constants.Authority.Prod);\r\n    }\r\n    var isMsa = authConfig.idp.toLowerCase() === Constants_1.Constants.IdentityProvider.Msa.toLowerCase();\r\n    if (isMsa) {\r\n        // There is no guarantee that our callers will send MSAL.js supported authority to us,\r\n        // hard code the authority to be login.microsoftonline.com since there is no PPE tenant for MSA.\r\n        authConfig.authority = Constants_1.Constants.Authority.Prod + Constants_1.Constants.Authority.MsaSuffix;\r\n    }\r\n    else {\r\n        if (!authConfig.authority) {\r\n            authConfig.authority = Constants_1.Constants.Authority.Prod + Constants_1.Constants.Authority.AadSuffix;\r\n        }\r\n        // Add common suffix if it doesn't have\r\n        if (authConfig.authority.indexOf(Constants_1.Constants.Authority.AadSuffix) < 0) {\r\n            if (authConfig.authority.charAt(authConfig.authority.length - 1) == \"/\")\r\n                authConfig.authority += Constants_1.Constants.Authority.AadSuffix;\r\n            else\r\n                authConfig.authority += \"/\" + Constants_1.Constants.Authority.AadSuffix;\r\n        }\r\n    }\r\n    return MsalWrapper((authConfig.timeoutToLoad) ? authConfig.timeoutToLoad : 2000).then(function (msalInstance) {\r\n        exports.applications = applications = new Array();\r\n        var defaultAppId;\r\n        for (var _i = 0, _a = authConfig.appIds; _i < _a.length; _i++) {\r\n            var appId = _a[_i];\r\n            LoggingUtils_1.LoggingUtils.log(\"[Load->MsalWrapper->MsalInit] \" + appId + \": \" + authConfig.idp);\r\n            if (!appId || !ValidateUtils_1.ValidateUtils.isGuid(appId)) {\r\n                continue;\r\n            }\r\n            var application = new msalInstance.PublicClientApplication({\r\n                auth: {\r\n                    clientId: appId,\r\n                    authority: authConfig.authority,\r\n                    redirectUri: (authConfig.redirectUri) ? authConfig.redirectUri.split(\"?\")[0] : location.href.split(\"?\")[0],\r\n                    navigateToLoginRequestUrl: (authConfig.navigateToLoginRequestUrl) ? authConfig.navigateToLoginRequestUrl : true,\r\n                },\r\n                cache: {\r\n                    cacheLocation: 'localStorage',\r\n                    // Store auth state in cookies can make the request too big and fail the request sometimes, need to keep it as false.\r\n                    storeAuthStateInCookie: false\r\n                },\r\n                system: {\r\n                    loadFrameTimeout: (authConfig.timeout) ? authConfig.timeout : 6000,\r\n                },\r\n            });\r\n            var entry = { applicationId: appId, application: application };\r\n            applications.push(entry);\r\n            // Keep first valid app for pre-fetch\r\n            if (!defaultAppId)\r\n                defaultAppId = appId;\r\n        }\r\n        ;\r\n        if (!defaultAppId)\r\n            return Promise.reject(LogTelemetryDataFieldsForLoad(false, correlationId, applications, timerClock));\r\n        LoggingUtils_1.LoggingUtils.log(\"[Load->SsoSilentWrapper] \" + defaultAppId + \": \" + authConfig.idp);\r\n        return SsoSilentWrapper(defaultAppId, authConfig.upn, isMsa ? Constants_1.Constants.Authority.MsaSuffix : Constants_1.Constants.Authority.AadSuffix, correlationId).then(function (ssoResult) {\r\n            LoggingUtils_1.LoggingUtils.log(\"[Load->SsoSilentWrapper] \" + defaultAppId + \": success: \" + ssoResult.idTokenClaims[\"aud\"]);\r\n            return LogTelemetryDataFieldsForLoad(true, correlationId, applications, timerClock);\r\n        }).catch(function (ssoError) {\r\n            LoggingUtils_1.LoggingUtils.log(\"[Load->SsoSilentWrapper] \" + defaultAppId + \": error: [\" + ssoError.errorCode + \"]\" + ssoError.errorMessage);\r\n            return LogTelemetryDataFieldsForLoad(true, correlationId, applications, timerClock, ssoError.errorCode, ssoError.errorMessage);\r\n        });\r\n    }).catch(function () {\r\n        LoggingUtils_1.LoggingUtils.log(\"[Load->MsalWrapper] msal is not loaded\");\r\n        return Promise.reject(LogTelemetryDataFieldsForLoad(false, correlationId, applications, timerClock));\r\n    });\r\n}\r\nexports.Load = Load;\r\n/**\r\n * Acquire an access token by given target\r\n * @param target - resource for V1 token, scope for V2 token\r\n * @param applicationId - the application ID which needs access token\r\n * @param correlationId - the same correlation ID exists under the caller's context, the same correlation ID will passed on to MSAL.js for unified experience\r\n * @param login - If true, shows a login dialog. If false, skips login. TODO: Remove after migration in WAC\r\n * @param popup - If true, popsup a dialog for interactive flow. If false, acquires token silently.\r\n * @param forThirdParty - If true, treats the caller as third-party and avoids sending PII telemetry.\r\n * @param claims - Claims from AAD to be used in scenarios such as credentials change or MFA\r\n * @returns {Promise.<IBrowserAuthResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link IBrowserAuthResult} object\r\n */\r\nfunction GetToken(target, applicationId, correlationId, login, popup, forThirdParty, claims) {\r\n    var _this = this;\r\n    if (forThirdParty === void 0) { forThirdParty = false; }\r\n    var timerClock = TimerUtils_1.TimerUtils.timer();\r\n    var isPopup = login || popup; //TODO:Need to deprecate login because one popup can control. Deprecate after WAC migration.\r\n    var is3rdPartyCookie = false;\r\n    var application = GetApplication(applicationId);\r\n    var result = {};\r\n    var isMsa = authConfig.idp.toLowerCase() === Constants_1.Constants.IdentityProvider.Msa.toLowerCase();\r\n    // Wrong format of correlation ID or blank are not valid in MSAL.js\r\n    // With an invalid correlation ID in the request, the access token acquiring request will be rejected by MSAL.js with exceptions.\r\n    // Correlation ID will be set to undefined in those cases and MSAL.js will generate a new correlation ID if it is undefined.\r\n    if (!correlationId || !ValidateUtils_1.ValidateUtils.isGuid(correlationId)) {\r\n        correlationId = undefined;\r\n    }\r\n    if (!target) {\r\n        result.ErrorCode = 'missing_target';\r\n        result.ErrorMessage = 'The provided target for BrowserAuth.GetToken is null, blank or empty';\r\n        return Promise.reject(LogTelemetryDataFieldsForGetToken(result, correlationId, applicationId, forThirdParty, timerClock, undefined));\r\n    }\r\n    var scopes = [ValidateUtils_1.ValidateUtils.getScope(target)];\r\n    if (!applicationId || !ValidateUtils_1.ValidateUtils.isGuid(applicationId)) {\r\n        result.ErrorCode = 'invalid_application_ID';\r\n        result.ErrorMessage = 'The provided application ID for BrowserAuth.GetToken is null, blank, empty or with invalid format';\r\n        return Promise.reject(LogTelemetryDataFieldsForGetToken(result, correlationId, applicationId, forThirdParty, timerClock, scopes));\r\n    }\r\n    if (application === undefined || !application) {\r\n        result.ErrorCode = 'missing_msal';\r\n        result.ErrorMessage = 'BrowserAuth can\\'t find msal instance';\r\n        return Promise.reject(LogTelemetryDataFieldsForGetToken(result, correlationId, applicationId, forThirdParty, timerClock, undefined));\r\n    }\r\n    var acquireToken = function (tokenParams) {\r\n        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n            var tokenRequest;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": popup:[\" + isPopup + \"]\");\r\n                        // Reset result\r\n                        result = {};\r\n                        tokenRequest = (isPopup)\r\n                            ? application.acquireTokenPopup(tokenParams)\r\n                            : application.acquireTokenSilent(tokenParams);\r\n                        return [4 /*yield*/, tokenRequest.then(function (authResponse) {\r\n                                result.MsalResult = authResponse;\r\n                                if (authResponse.accessToken) {\r\n                                    if (ValidateUtils_1.ValidateUtils.upnMatchesUpnFromIdToken(authResponse.idToken, authConfig)\r\n                                        && (forThirdParty || isMsa || ValidateUtils_1.ValidateUtils.upnMatchesUpnFromAccessToken(authResponse.accessToken, authConfig))) {\r\n                                        result.Token = authResponse.accessToken;\r\n                                        LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": success: \" + result.Token);\r\n                                        return resolve(result);\r\n                                    }\r\n                                    else {\r\n                                        result.ErrorCode = \"upn_mismatch\";\r\n                                        result.ErrorMessage = \"upn doesn't match with given upn in config\";\r\n                                        LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": error: [\" + result.ErrorCode + \"]\" + result.ErrorMessage);\r\n                                        return reject(result);\r\n                                    }\r\n                                }\r\n                                result.ErrorCode = \"no_tokens_found\";\r\n                                result.ErrorMessage = \"Access token doesn't exist in auth response\";\r\n                                LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": error: [\" + result.ErrorCode + \"]\" + result.ErrorMessage);\r\n                                return reject(result);\r\n                            }).catch(function (error) {\r\n                                result.MsalResult = error;\r\n                                result.ErrorCode = error.errorCode;\r\n                                result.ErrorMessage = error.errorMessage;\r\n                                LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": error: [\" + result.ErrorCode + \"]\" + result.ErrorMessage);\r\n                                if (!isPopup && is3rdPartyCookie) {\r\n                                    isPopup = true;\r\n                                    LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": retry: popup:[\" + isPopup + \"]\");\r\n                                    acquireToken(tokenParams).then(function (result) { return resolve(result); }).catch(function (result) { return reject(result); });\r\n                                }\r\n                                else {\r\n                                    return reject(result);\r\n                                }\r\n                            })];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); });\r\n    };\r\n    var tokenParams = {\r\n        scopes: scopes,\r\n        account: { username: authConfig.upn },\r\n        loginHint: authConfig.upn,\r\n        extraQueryParameters: { domain_hint: isMsa ? Constants_1.Constants.Authority.MsaSuffix : Constants_1.Constants.Authority.AadSuffix },\r\n        correlationId: correlationId,\r\n        claims: claims\r\n    };\r\n    return acquireToken(tokenParams).catch(function (error) { return __awaiter(_this, void 0, void 0, function () {\r\n        var isSuccess;\r\n        var _this = this;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    isSuccess = false;\r\n                    if (!(error.ErrorCode === \"no_tokens_found\")) return [3 /*break*/, 2];\r\n                    LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": no_tokens_found\");\r\n                    return [4 /*yield*/, SsoSilentWrapper(applicationId, authConfig.upn, isMsa ? Constants_1.Constants.Authority.MsaSuffix : Constants_1.Constants.Authority.AadSuffix, correlationId).then(function () { return __awaiter(_this, void 0, void 0, function () {\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0:\r\n                                        LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken->SsoSilentWrapper] \" + applicationId + \": success\");\r\n                                        return [4 /*yield*/, acquireToken(tokenParams).then(function (tokenResult) {\r\n                                                isSuccess = true;\r\n                                                result = tokenResult;\r\n                                            }).catch(function (tokenResult) {\r\n                                                result = tokenResult;\r\n                                            })];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        }); }).catch(function (ssoError) { return __awaiter(_this, void 0, void 0, function () {\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0:\r\n                                        result.ErrorCode = ssoError.errorCode;\r\n                                        result.ErrorMessage = ssoError.errorMessage;\r\n                                        LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken->SsoSilentWrapper] \" + applicationId + \": error: [\" + result.ErrorCode + \"]\" + result.ErrorMessage);\r\n                                        if (!(ssoError.errorCode === 'login_required' && (ssoError.errorMessage.startsWith('AADSTS50058') || ssoError.errorMessage.startsWith('Silent authentication was denied')) && authConfig.autoPopup)) return [3 /*break*/, 2];\r\n                                        is3rdPartyCookie = true;\r\n                                        return [4 /*yield*/, acquireToken(tokenParams).then(function (tokenResult) {\r\n                                                isSuccess = true;\r\n                                                result = tokenResult;\r\n                                            }).catch(function (tokenResult) {\r\n                                                LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken->SsoSilentWrapper->Popup] \" + applicationId + \": error: [\" + result.ErrorCode + \"]\" + result.ErrorMessage);\r\n                                                result = tokenResult;\r\n                                            })];\r\n                                    case 1:\r\n                                        _a.sent();\r\n                                        _a.label = 2;\r\n                                    case 2: return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        }); })];\r\n                case 1:\r\n                    _a.sent();\r\n                    _a.label = 2;\r\n                case 2:\r\n                    LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken->isSuccess] \" + applicationId + \": [\" + isSuccess + \"]\");\r\n                    result = LogTelemetryDataFieldsForGetToken(result, correlationId, applicationId, forThirdParty, timerClock, scopes);\r\n                    return [2 /*return*/, isSuccess ? Promise.resolve(result) : Promise.reject(result)];\r\n            }\r\n        });\r\n    }); }).then(function (result) {\r\n        LoggingUtils_1.LoggingUtils.log(\"[GetToken->acquireToken] \" + applicationId + \": success\");\r\n        return Promise.resolve(LogTelemetryDataFieldsForGetToken(result, correlationId, applicationId, forThirdParty, timerClock, scopes));\r\n    });\r\n}\r\nexports.GetToken = GetToken;\r\n/**\r\n * Acquire an access token by given target with load\r\n * @param target - resource for V1 token, scope for V2 token\r\n * @param applicationId - the application ID which needs access token\r\n * @param isMSA - Identity Type is MSA or not\r\n * @param isPPE - PPE or Prod Authority\r\n * @returns {Promise.<IBrowserAuthResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link IBrowserAuthResult} object\r\n */\r\nfunction GetTokenOnce(target, applicationId, isMSA, isPPE) {\r\n    if (isMSA === void 0) { isMSA = false; }\r\n    if (isPPE === void 0) { isPPE = false; }\r\n    return Load({\r\n        idp: isMSA ? Constants_1.Constants.IdentityProvider.Msa.toLowerCase() : Constants_1.Constants.IdentityProvider.Aad.toLowerCase(),\r\n        appIds: [applicationId],\r\n        authority: isPPE ? Constants_1.Constants.Authority.Ppe : Constants_1.Constants.Authority.Prod,\r\n        upn: \"\",\r\n        autoPopup: true,\r\n        enableConsoleLogging: true\r\n    }).then(function () {\r\n        // GetToken\r\n        return GetToken(target, applicationId, undefined, true);\r\n    }).catch(function (loadFailure) {\r\n        return Promise.reject(loadFailure);\r\n    });\r\n}\r\nexports.GetTokenOnce = GetTokenOnce;\r\n/**\r\n * Wrapper of msal object\r\n */\r\nfunction MsalWrapper(max) {\r\n    if (max === void 0) { max = 2000; }\r\n    return new Promise(function (resolve, reject) {\r\n        var msalExisted = function () {\r\n            try {\r\n                return (msal !== undefined && !!msal);\r\n            }\r\n            catch (error) {\r\n                return false;\r\n            }\r\n        };\r\n        var waited = 0;\r\n        var interval = 500;\r\n        var delay = setInterval(function () {\r\n            waited += interval;\r\n            if (msalExisted()) {\r\n                clearInterval(delay);\r\n                return resolve(msal);\r\n            }\r\n            else if (waited > max) {\r\n                clearInterval(delay);\r\n                return reject(null);\r\n            }\r\n        }, interval);\r\n    });\r\n}\r\nexports.MsalWrapper = MsalWrapper;\r\n/**\r\n * Wrapper of ssoSilent for easy unit testing\r\n */\r\nfunction SsoSilentWrapper(appId, upn, domain_hint, correlationId) {\r\n    var application = GetApplication(appId);\r\n    return application.ssoSilent({\r\n        loginHint: upn,\r\n        extraQueryParameters: { domain_hint: domain_hint },\r\n        correlationId: correlationId,\r\n    });\r\n}\r\nexports.SsoSilentWrapper = SsoSilentWrapper;\r\n/**\r\n * Construct the Msal.PublicClientApplication instance for V2 endpoint calls.\r\n * @param applicationId - the application ID used to find or construct the MSAL instance.\r\n * @returns the Msal.PublicClientApplication instance to make calls to V2 endpoint.\r\n */\r\nfunction GetApplication(applicationId) {\r\n    var application;\r\n    if (applications) {\r\n        applications.some(function (value) {\r\n            if (applicationId && value.applicationId && applicationId.toUpperCase() === value.applicationId.toUpperCase()) {\r\n                application = value.application;\r\n                LoggingUtils_1.LoggingUtils.log(\"[GetApplication] \" + applicationId + \": Found\");\r\n                return true;\r\n            }\r\n            LoggingUtils_1.LoggingUtils.log(\"[GetApplication] \" + applicationId + \": Not Found\");\r\n            return false;\r\n        });\r\n    }\r\n    if (!application && !!msalInstance) {\r\n        LoggingUtils_1.LoggingUtils.log(\"[GetApplication] \" + applicationId + \": Add\");\r\n        application = new msalInstance.PublicClientApplication({\r\n            auth: {\r\n                clientId: applicationId,\r\n                authority: authConfig.authority,\r\n                redirectUri: (authConfig.redirectUri) ? authConfig.redirectUri.split(\"?\")[0] : location.href.split(\"?\")[0],\r\n                navigateToLoginRequestUrl: (authConfig.navigateToLoginRequestUrl) ? authConfig.navigateToLoginRequestUrl : true,\r\n            },\r\n            cache: {\r\n                cacheLocation: 'localStorage',\r\n                // Store auth state in cookies can make the request too big and fail the request sometimes, need to keep it as false.\r\n                storeAuthStateInCookie: false\r\n            },\r\n            system: {\r\n                loadFrameTimeout: (authConfig.timeout) ? authConfig.timeout : 6000,\r\n            },\r\n        });\r\n        var entry = { applicationId: applicationId, application: application };\r\n        applications.push(entry);\r\n    }\r\n    return application;\r\n}\r\nexports.GetApplication = GetApplication;\r\n/**\r\n * Acquire an Id token by given upn/target, and check if the upn matches context\r\n * @param correlationId - the same correlation ID exists under the caller's context, the same correlation ID will passed on to MSAL.js for unified experience\r\n * @returns {Promise.<IBrowserAuthUpnResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link IBrowserAuthUpnResult} object\r\n */\r\nfunction CheckUpnMatchIdToken(applicationId, correlationId) {\r\n    var timerClock = TimerUtils_1.TimerUtils.timer();\r\n    // Wrong format of correlation ID or blank are not valid in MSAL.js\r\n    // With an invalid correlation ID in the request, the access token acquiring request will be rejected by MSAL.js with exceptions.\r\n    // Correlation ID will be set to undefined in those cases and MSAL.js will generate a new correlation ID if it is undefined.\r\n    if (!correlationId || !ValidateUtils_1.ValidateUtils.isGuid(correlationId)) {\r\n        correlationId = undefined;\r\n    }\r\n    var result = {};\r\n    if (!applicationId || !ValidateUtils_1.ValidateUtils.isGuid(applicationId)) {\r\n        result.ErrorCode = 'invalid_application_ID';\r\n        result.ErrorMessage = 'The provided application ID for BrowserAuth.CheckUpnMatchIdToken is null, blank, empty or with invalid format';\r\n        LogTelemetryDataFieldsForCheckUpn(result, correlationId, applicationId, timerClock, undefined, result.ErrorCode, result.ErrorMessage);\r\n        return Promise.reject(result);\r\n    }\r\n    var application = GetApplication(applicationId);\r\n    if (application === undefined || !application) {\r\n        result.ErrorCode = 'missing_msal';\r\n        result.ErrorMessage = 'BrowserAuth can\\'t find msal instance';\r\n        return Promise.reject();\r\n    }\r\n    var scopes = [applicationId]; /*It will acquire id token instead of access token if resource/scope is clientId*/\r\n    return new Promise(function (resolve, reject) {\r\n        var currentAccount = application.getAccountByUsername(authConfig.upn);\r\n        LoggingUtils_1.LoggingUtils.log(\"[CheckUpnMatchIdToken] \" + applicationId + \": Calls acquireTokenSilent\");\r\n        application.acquireTokenSilent({\r\n            scopes: scopes,\r\n            account: currentAccount,\r\n            correlationId: correlationId,\r\n        }).then(function (authResponse) {\r\n            result.IsUpnMatch = ValidateUtils_1.ValidateUtils.upnMatchesUpnFromIdToken(authResponse.idToken, authConfig);\r\n            if (result.IsUpnMatch) {\r\n                LogTelemetryDataFieldsForCheckUpn(result, correlationId, applicationId, timerClock, scopes);\r\n                return resolve(result);\r\n            }\r\n        }).catch(function (error) {\r\n            result.ErrorCode = error.errorCode;\r\n            result.ErrorMessage = error.errorMessage;\r\n            LoggingUtils_1.LoggingUtils.log(\"[CheckUpnMatchIdToken] \" + applicationId + \": error: \" + result.ErrorMessage);\r\n            result.IsUpnMatch = false;\r\n            LogTelemetryDataFieldsForCheckUpn(result, correlationId, applicationId, timerClock, scopes, error.errorCode, error.errorMessage);\r\n            return reject(result);\r\n        });\r\n    });\r\n}\r\nexports.CheckUpnMatchIdToken = CheckUpnMatchIdToken;\r\n/**\r\n * Log the telemetry data points in the provided or Otel pipeline.\r\n * @param result - the result to log the telemetry data points into\r\n * @param correlationId - the same correlation ID exists under the caller's context, the same correlation ID will passed on to MSAL.js for unified experience\r\n * @param applications - the application ID in the access token request\r\n * @param timerClock - the timerClock to log the time duration\r\n * @param errorCode - the error code included in the exception, if any\r\n * @param errorMessage - the error message included in the exception, if any\r\n */\r\nfunction LogTelemetryDataFieldsForLoad(result, correlationId, applications, timerClock, errorCode, errorMessage) {\r\n    if (!authConfig.telemetryInstance && typeof OTel === \"undefined\") {\r\n        // For data fields that are null, blank or empty, the value is set to \"unknown\" at this point\r\n        // based on office-online-otel documentation: https://office.visualstudio.com/OC/_git/office-online-ui?path=%2Fpackages%2Foffice-online-otel%2FREADME.md&version=GBmaster\r\n        // Null or undefined value will cause exceptions down the line.\r\n        var dataFields = [\r\n            { name: Constants_1.Constants.Telemetry.Duration, int64: timerClock.ms },\r\n            { name: Constants_1.Constants.Telemetry.Succeeded, bool: true },\r\n            { name: Constants_1.Constants.Telemetry.IdentityProvider, string: authConfig.idp.toLowerCase() },\r\n            { name: Constants_1.Constants.Telemetry.CorrelationId, string: correlationId ? correlationId : 'unknown' },\r\n            { name: Constants_1.Constants.Telemetry.LoadedApplicationCount, int64: applications ? applications.length : 0 },\r\n            { name: Constants_1.Constants.Telemetry.ErrorCode, string: errorCode ? errorCode : 'unknown' },\r\n            { name: Constants_1.Constants.Telemetry.ErrorMessage, string: errorMessage ? errorMessage : 'unknown' },\r\n        ];\r\n        api_js_1.sendTelemetryEvent({\r\n            name: Constants_1.Constants.Telemetry.LoadTelemetryName,\r\n            dataFields: dataFields\r\n        });\r\n    }\r\n    return {\r\n        Telemetry: {\r\n            timeToLoad: timerClock.ms,\r\n            succeeded: result,\r\n            idp: authConfig.idp.toLowerCase(),\r\n            correlationId: correlationId ? correlationId : '',\r\n            loadedApplicationCount: applications ? applications.length : 0,\r\n            errorCode: errorCode ? errorCode : undefined,\r\n            errorMessage: errorMessage ? errorMessage : undefined,\r\n        }\r\n    };\r\n}\r\n/**\r\n * Log the telemetry data points in the provided {@link IBrowserAuthResult} or Otel pipeline.\r\n * @param result - the provided {@link IBrowserAuthResult} to log the telemetry data points into\r\n * @param correlationId - the same correlation ID exists under the caller's context, the same correlation ID will passed on to MSAL.js for unified experience\r\n * @param applicationId - the application ID in the access token request\r\n * @param forThirdParty - If true, treats the caller as third-party and avoids sending PII telemetry\r\n * @param timerClock - the timerClock to log the time duration\r\n * @param scopes - the scopes in the acquire token request\r\n */\r\nfunction LogTelemetryDataFieldsForGetToken(result, correlationId, applicationId, forThirdParty, timerClock, scopes) {\r\n    if (!authConfig.telemetryInstance && typeof OTel === \"undefined\") {\r\n        // For data fields that are null, blank or empty, the value is set to \"unknown\" at this point\r\n        // based on office-online-otel documentation: https://office.visualstudio.com/OC/_git/office-online-ui?path=%2Fpackages%2Foffice-online-otel%2FREADME.md&version=GBmaster\r\n        // Null or undefined value will cause exceptions down the line.\r\n        var dataFields = [\r\n            { name: Constants_1.Constants.Telemetry.Duration, int64: timerClock.ms },\r\n            { name: Constants_1.Constants.Telemetry.Succeeded, string: result.Token ? false : true },\r\n            { name: Constants_1.Constants.Telemetry.IdentityProvider, string: authConfig.idp.toLowerCase() },\r\n            { name: Constants_1.Constants.Telemetry.ApplicationId, string: applicationId },\r\n            { name: Constants_1.Constants.Telemetry.TokenScope, string: (scopes && !forThirdParty) ? scopes.toString() : 'unknown' },\r\n            { name: Constants_1.Constants.Telemetry.CorrelationId, string: correlationId ? correlationId : 'unknown' },\r\n            { name: Constants_1.Constants.Telemetry.ErrorCode, string: result.ErrorCode ? result.ErrorCode : 'unknown' },\r\n            { name: Constants_1.Constants.Telemetry.ErrorMessage, string: (result.ErrorMessage && !forThirdParty) ? result.ErrorMessage : 'unknown' },\r\n            { name: Constants_1.Constants.Telemetry.ErrorCodeForGetToken, string: result.ErrorCode ? result.ErrorCode : 'unknown' },\r\n            { name: Constants_1.Constants.Telemetry.ErrorMessageForGetToken, string: (result.ErrorMessage && !forThirdParty) ? result.ErrorMessage : 'unknown' },\r\n        ];\r\n        api_js_1.sendTelemetryEvent({\r\n            name: Constants_1.Constants.Telemetry.GetTokenTelemetryName,\r\n            dataFields: dataFields\r\n        });\r\n    }\r\n    result.Telemetry = {\r\n        timeToGetToken: timerClock.ms,\r\n        succeeded: result.Token ? false : true,\r\n        idp: authConfig.idp.toLowerCase(),\r\n        applicationId: applicationId,\r\n        tokenScope: scopes && !forThirdParty ? scopes.toString() : undefined,\r\n        correlationId: correlationId,\r\n        errorCode: result.ErrorCode ? result.ErrorCode : undefined,\r\n        errorMessage: result.ErrorMessage && !forThirdParty ? result.ErrorMessage : undefined,\r\n        errorCodeForGetToken: result.ErrorCode ? result.ErrorCode : undefined,\r\n        errorMessageForGetToken: result.ErrorMessage && !forThirdParty ? result.ErrorMessage : undefined,\r\n        fromCache: result.MsalResult ? !!result.MsalResult.fromCache : false,\r\n        expiresOn: result.MsalResult && result.MsalResult.expiresOn ? result.MsalResult.expiresOn.getTime() / 1000 : undefined\r\n    };\r\n    return result;\r\n}\r\n/**\r\n * * Log the telemetry data points in the provided {@link IBrowserAuthUpnResult} or Otel pipeline.\r\n * @param result - the provided {@link IBrowserAuthUpnResult} to log the telemetry data points into\r\n * @param correlationId - the same correlation ID exists under the caller's context, the same correlation ID will passed on to MSAL.js for unified experience\r\n * @param applicationId - the application ID in the access token request\r\n * @param timerClock - the timerClock to log the time duration\r\n * @param scopes - the scopes in the acquire token request\r\n * @param errorCode - the error code included in the exception, if any\r\n * @param errorMessage - the error message included in the exception, if any\r\n */\r\nfunction LogTelemetryDataFieldsForCheckUpn(result, correlationId, applicationId, timerClock, scopes, errorCode, errorMessage) {\r\n    // For data fields that are null, blank or empty, the value is set to \"unknown\" at this point\r\n    // based on office-online-otel documentation: https://office.visualstudio.com/OC/_git/office-online-ui?path=%2Fpackages%2Foffice-online-otel%2FREADME.md&version=GBmaster\r\n    // Null or undefined value will cause exceptions down the line.\r\n    var dataFields = [\r\n        { name: Constants_1.Constants.Telemetry.Duration, int64: timerClock.ms },\r\n        { name: Constants_1.Constants.Telemetry.Succeeded, bool: errorCode ? false : true },\r\n        { name: Constants_1.Constants.Telemetry.IdentityProvider, string: authConfig.idp.toLowerCase() },\r\n        { name: Constants_1.Constants.Telemetry.ApplicationId, string: applicationId },\r\n        { name: Constants_1.Constants.Telemetry.TokenScope, string: scopes ? scopes.toString() : 'unknown' },\r\n        { name: Constants_1.Constants.Telemetry.CorrelationId, string: correlationId ? correlationId : 'unknown' },\r\n        { name: Constants_1.Constants.Telemetry.ErrorCode, string: errorCode ? errorCode : 'unknown' },\r\n        { name: Constants_1.Constants.Telemetry.ErrorMessage, string: errorMessage ? errorMessage : 'unknown' },\r\n        { name: Constants_1.Constants.Telemetry.ErrorCodeForCheckUpn, string: errorCode ? errorCode : 'unknown' },\r\n        { name: Constants_1.Constants.Telemetry.ErrorMessageForCheckUpn, string: errorMessage ? errorMessage : 'unknown' } //TODO: Deprecate after partner migration\r\n    ];\r\n    if (!authConfig.telemetryInstance && typeof OTel === \"undefined\") {\r\n        api_js_1.sendTelemetryEvent({\r\n            name: Constants_1.Constants.Telemetry.CheckUpnTelemetryName,\r\n            dataFields: dataFields\r\n        });\r\n    }\r\n    result.Telemetry = {\r\n        timeToCheckUPN: timerClock.ms,\r\n        succeeded: errorCode ? false : true,\r\n        idp: authConfig.idp.toLowerCase(),\r\n        applicationId: applicationId,\r\n        tokenScope: scopes ? scopes.toString() : undefined,\r\n        correlationId: correlationId,\r\n        errorCode: errorCode,\r\n        errorMessage: errorMessage,\r\n        errorCodeForCheckUPN: errorCode,\r\n        errorMessageForCheckUPN: errorMessage //TODO: Deprecate after partner migration\r\n    };\r\n}\r\n/**\r\n * Logout current user from all registered applications\r\n */\r\nfunction Logout() {\r\n    applications.forEach(function (entry) {\r\n        LoggingUtils_1.LoggingUtils.log(\"[Logout] application calls logout\");\r\n        entry.application.logout();\r\n    });\r\n    // Also clear registered applications\r\n    exports.applications = applications = new Array();\r\n}\r\nexports.Logout = Logout;\r\n\n\n//# sourceURL=webpack://BrowserAuth/./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/BrowserAuth.ts?");

/***/ }),

/***/ "./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/Constants.ts":
/*!**********************************************************************************!*\
  !*** ./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/Constants.ts ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Constants;\r\n(function (Constants) {\r\n    var IdentityProvider = /** @class */ (function () {\r\n        function IdentityProvider() {\r\n        }\r\n        /**\r\n         * AAD\r\n         */\r\n        IdentityProvider.Aad = \"aad\";\r\n        /**\r\n         * MSA\r\n         */\r\n        IdentityProvider.Msa = \"msa\";\r\n        return IdentityProvider;\r\n    }());\r\n    Constants.IdentityProvider = IdentityProvider;\r\n    var PostMessageType = /** @class */ (function () {\r\n        function PostMessageType() {\r\n        }\r\n        PostMessageType.RequestAuthConfig = \"RequestAuthConfig\";\r\n        PostMessageType.ResponseAuthConfig = \"ResponseAuthConfig\";\r\n        PostMessageType.iFrameIdTokenPrefix = \"msalIdTokenFrame\";\r\n        PostMessageType.iFramePrefix = \"msalRenewFrame\";\r\n        return PostMessageType;\r\n    }());\r\n    Constants.PostMessageType = PostMessageType;\r\n    var Authority = /** @class */ (function () {\r\n        function Authority() {\r\n        }\r\n        /**\r\n         * Prod\r\n         */\r\n        Authority.Prod = \"https://login.microsoftonline.com/\";\r\n        /**\r\n         * Legacy Prod\r\n         */\r\n        Authority.ProdLegacy = \"https://login.windows.net/\";\r\n        /**\r\n         * PPE\r\n         */\r\n        Authority.Ppe = \"https://login.windows-ppe.net/\";\r\n        Authority.AadSuffix = \"organizations\";\r\n        Authority.MsaSuffix = \"consumers\";\r\n        return Authority;\r\n    }());\r\n    Constants.Authority = Authority;\r\n    var Telemetry = /** @class */ (function () {\r\n        function Telemetry() {\r\n        }\r\n        Telemetry.OtelInstance = \"otel\";\r\n        Telemetry.CheckUpnTelemetryName = \"Office.Identity.WebAuth.BrowserAuth.CheckUpn\";\r\n        Telemetry.GetTokenTelemetryName = \"Office.Identity.WebAuth.BrowserAuth.GetToken\";\r\n        Telemetry.LoadTelemetryName = \"Office.Identity.WebAuth.BrowserAuth.Load\";\r\n        Telemetry.Duration = \"Duration\";\r\n        Telemetry.Succeeded = \"Succeeded\";\r\n        Telemetry.ApplicationId = \"ApplicationId\";\r\n        Telemetry.CorrelationId = \"CorrelationId\";\r\n        Telemetry.IdentityProvider = \"IdentityProvider\";\r\n        Telemetry.LoadedApplicationCount = \"LoadedApplicationCount\";\r\n        Telemetry.TokenScope = \"TokenScope\";\r\n        Telemetry.ErrorCode = \"ErrorCode\";\r\n        Telemetry.ErrorMessage = \"ErrorMessage\";\r\n        Telemetry.ErrorCodeForLoad = \"ErrorCodeForLoad\";\r\n        Telemetry.ErrorMessageForLoad = \"ErrorMessageForLoad\";\r\n        Telemetry.ErrorCodeForGetToken = \"ErrorCodeForGetToken\";\r\n        Telemetry.ErrorMessageForGetToken = \"ErrorMessageForGetToken\";\r\n        Telemetry.ErrorCodeForCheckUpn = \"ErrorCodeForCheckUpn\";\r\n        Telemetry.ErrorMessageForCheckUpn = \"ErrorMessageForCheckUpn\";\r\n        return Telemetry;\r\n    }());\r\n    Constants.Telemetry = Telemetry;\r\n})(Constants = exports.Constants || (exports.Constants = {}));\r\n\n\n//# sourceURL=webpack://BrowserAuth/./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/Constants.ts?");

/***/ }),

/***/ "./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ExtractUtils.ts":
/*!*************************************************************************************!*\
  !*** ./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ExtractUtils.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Internal Module contains utility methods for extracting tokens\r\n */\r\nvar LoggingUtils_1 = __webpack_require__(/*! ./LoggingUtils */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/LoggingUtils.ts\");\r\nvar ExtractUtils = /** @class */ (function () {\r\n    function ExtractUtils() {\r\n    }\r\n    /**\r\n     * Extract token by decoding the RAW token\r\n     *\r\n     * @param encodedToken\r\n     */\r\n    ExtractUtils.extractToken = function (encodedToken) {\r\n        var decodedToken = this.decodeJwt(encodedToken);\r\n        if (!decodedToken) {\r\n            return null;\r\n        }\r\n        try {\r\n            var base64Token = decodedToken.JWSPayload;\r\n            var base64Decoded = this.base64Decode(base64Token);\r\n            if (!base64Decoded) {\r\n                LoggingUtils_1.LoggingUtils.log(\"The returned token could not be base64 url safe decoded.\");\r\n                return null;\r\n            }\r\n            // ECMA script has JSON built-in support\r\n            return JSON.parse(base64Decoded);\r\n        }\r\n        catch (err) {\r\n            LoggingUtils_1.LoggingUtils.error(\"The returned token could not be decoded\" + err);\r\n        }\r\n        return null;\r\n    };\r\n    ;\r\n    /**\r\n     * Decodes a base64 encoded string.\r\n     *\r\n     * @param input\r\n     */\r\n    ExtractUtils.base64Decode = function (input) {\r\n        var encodedString = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\r\n        switch (encodedString.length % 4) {\r\n            case 0:\r\n                break;\r\n            case 2:\r\n                encodedString += \"==\";\r\n                break;\r\n            case 3:\r\n                encodedString += \"=\";\r\n                break;\r\n            default:\r\n                throw new Error(\"Invalid base64 string\");\r\n        }\r\n        return decodeURIComponent(atob(encodedString).split(\"\").map(function (c) {\r\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\r\n        }).join(\"\"));\r\n    };\r\n    ;\r\n    /**\r\n     * decode a JWT\r\n     *\r\n     * @param jwtToken\r\n     */\r\n    ExtractUtils.decodeJwt = function (jwtToken) {\r\n        if (jwtToken === \"undefined\" || !jwtToken || 0 === jwtToken.length) {\r\n            return null;\r\n        }\r\n        var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\r\n        var matches = idTokenPartsRegex.exec(jwtToken);\r\n        if (!matches || matches.length < 4) {\r\n            LoggingUtils_1.LoggingUtils.warn(\"The returned access_token is not parseable.\");\r\n            return null;\r\n        }\r\n        var crackedToken = {\r\n            header: matches[1],\r\n            JWSPayload: matches[2],\r\n            JWSSig: matches[3]\r\n        };\r\n        return crackedToken;\r\n    };\r\n    ;\r\n    return ExtractUtils;\r\n}());\r\nexports.ExtractUtils = ExtractUtils;\r\n\n\n//# sourceURL=webpack://BrowserAuth/./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ExtractUtils.ts?");

/***/ }),

/***/ "./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/LoggingUtils.ts":
/*!*************************************************************************************!*\
  !*** ./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/LoggingUtils.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Internal Module contains utility methods for logging\r\n */\r\nvar LoggingUtils = /** @class */ (function () {\r\n    function LoggingUtils() {\r\n    }\r\n    /**\r\n     * Logs message to the console\r\n     * @param message - message which was passed in\r\n     * @param shouldLog - should this message be logged\r\n     */\r\n    LoggingUtils.log = function (message, shouldLog) {\r\n        if (!this.shouldProceed(shouldLog)) {\r\n            return false;\r\n        }\r\n        console.log(message);\r\n        return true;\r\n    };\r\n    /**\r\n     * Logs warning message to the console\r\n     * @param message - message which was passed in\r\n     * @param shouldLog - should this message be logged\r\n     */\r\n    LoggingUtils.warn = function (message, shouldLog) {\r\n        if (!this.shouldProceed(shouldLog)) {\r\n            return false;\r\n        }\r\n        console.warn(message);\r\n        return true;\r\n    };\r\n    /**\r\n     * Logs error message to the console\r\n     * @param message - message which was passed in\r\n     * @param shouldLog - should this message be logged\r\n     */\r\n    LoggingUtils.error = function (message, shouldLog) {\r\n        if (!this.shouldProceed(shouldLog)) {\r\n            return false;\r\n        }\r\n        console.error(message);\r\n        return true;\r\n    };\r\n    /**\r\n     * Returns if we should proceed with logging or not\r\n     * @param shouldLog - should this message be logged\r\n     */\r\n    LoggingUtils.shouldProceed = function (shouldLog) {\r\n        if (shouldLog != null && shouldLog !== undefined && !shouldLog) {\r\n            return false;\r\n        }\r\n        if (shouldLog == null && shouldLog === undefined && !this.enableConsoleLogging) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    LoggingUtils.enableConsoleLogging = false;\r\n    return LoggingUtils;\r\n}());\r\nexports.LoggingUtils = LoggingUtils;\r\n\n\n//# sourceURL=webpack://BrowserAuth/./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/LoggingUtils.ts?");

/***/ }),

/***/ "./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/TimerUtils.ts":
/*!***********************************************************************************!*\
  !*** ./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/TimerUtils.ts ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Module includes timer related utilities\r\n */\r\nvar TimerUtils = /** @class */ (function () {\r\n    function TimerUtils() {\r\n    }\r\n    /**\r\n     * Timer function\r\n     */\r\n    TimerUtils.timer = function () {\r\n        var timeStart = new Date().getTime();\r\n        return {\r\n            /**\r\n             * Returns time in seconds (example: 500)\r\n             */\r\n            get seconds() {\r\n                var seconds = Math.ceil((new Date().getTime() - timeStart) / 1000);\r\n                return seconds;\r\n            },\r\n            /**\r\n             * Returns time in Milliseconds (example: 2000)\r\n             */\r\n            get ms() {\r\n                var ms = (new Date().getTime() - timeStart);\r\n                return ms;\r\n            },\r\n            /**\r\n             * Returns formatted time in seconds (example: 500s)\r\n             */\r\n            get formattedSeconds() {\r\n                var seconds = Math.ceil(this.seconds / 1000) + \"s\";\r\n                return seconds;\r\n            },\r\n            /**\r\n             * Returns formatted time in Milliseconds (example: 2000ms)\r\n             */\r\n            get formattedMs() {\r\n                var ms = this.ms + \"ms\";\r\n                return ms;\r\n            }\r\n        };\r\n    };\r\n    return TimerUtils;\r\n}());\r\nexports.TimerUtils = TimerUtils;\r\n\n\n//# sourceURL=webpack://BrowserAuth/./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/TimerUtils.ts?");

/***/ }),

/***/ "./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ValidateUtils.ts":
/*!**************************************************************************************!*\
  !*** ./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ValidateUtils.ts ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Internal Module contains utility methods for validation\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ExtractUtils_1 = __webpack_require__(/*! ./ExtractUtils */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ExtractUtils.ts\");\r\nvar LoggingUtils_1 = __webpack_require__(/*! ./LoggingUtils */ \"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/LoggingUtils.ts\");\r\nvar ValidateUtils = /** @class */ (function () {\r\n    function ValidateUtils() {\r\n    }\r\n    /**\r\n     * Construct the scope for V2 endpoint calls.\r\n     * @param target - resource for V1 token, scope for V2 token\r\n     * @returns the right scope to make calls to V2 endpoint.\r\n     */\r\n    ValidateUtils.getScope = function (target) {\r\n        // To consume V2 endpoint, \"/.default\" needs to be added for given resources.\r\n        var resourcePrefix = [\"HTTPS:\", \"API:\"];\r\n        if (resourcePrefix.some(function (prefix) { return target.toLocaleUpperCase().startsWith(prefix); }) || this.isGuid(target)) {\r\n            return target + \"/.default\";\r\n        }\r\n        // Other cases could be that it is acquiring V2 tokens with scopes \"ConnectedServices.ReadWrite\" etc\r\n        // or wl.skydrive\r\n        return target;\r\n    };\r\n    /**\r\n     * Check whether the given string is in GUID format or not.\r\n     * @param str - provided string for format checking.\r\n     * @returns true if the string is in GUID format, returns false otherwise.\r\n     */\r\n    ValidateUtils.isGuid = function (str) {\r\n        // Checking GUID based on the GUID format\r\n        var regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n        return regexGuid.test(str);\r\n    };\r\n    /**\r\n     * Verify the upn in the config matches the upn in the id token\r\n     * @param token - the token to extract the upn from.\r\n     * @returns true if there is a match or there is no upn in the config\r\n     */\r\n    ValidateUtils.upnMatchesUpnFromIdToken = function (token, authConfig) {\r\n        if (!this.enableUpnCheck) {\r\n            // Skip upn check if enableUpnCheck is not true\r\n            LoggingUtils_1.LoggingUtils.log('Skip Upn check of id token, returning true');\r\n            return true;\r\n        }\r\n        if (!authConfig || !authConfig.upn) {\r\n            LoggingUtils_1.LoggingUtils.log('Upn does not exist in the configuration, returning true');\r\n            return true;\r\n        }\r\n        var idToken = ExtractUtils_1.ExtractUtils.extractToken(token);\r\n        // IdToken extraction would not work for future encrypted JWE tokens,\r\n        // If cannot be extracted, also return true\r\n        if (!idToken || (idToken && idToken.preferred_username && idToken.preferred_username.toLowerCase() === authConfig.upn.toLowerCase())) {\r\n            return true;\r\n        }\r\n        LoggingUtils_1.LoggingUtils.log('provided Upn does not match Upn extracted from id token');\r\n        return false;\r\n    };\r\n    /**\r\n     * Verify the upn in the id token matches the Upn in the access token\r\n     * @param token - the token to extract the upn from\r\n     * @returns true if there is a match or there is no upn in the id token or access token\r\n     */\r\n    ValidateUtils.upnMatchesUpnFromAccessToken = function (token, authConfig) {\r\n        if (!this.enableUpnCheck) {\r\n            // Skip upn check if enableUpnCheck is not true\r\n            LoggingUtils_1.LoggingUtils.log('Skip Upn check of access token, returning true');\r\n            return true;\r\n        }\r\n        if (!authConfig || !authConfig.upn) {\r\n            LoggingUtils_1.LoggingUtils.log('Upn does not exist in the configuration, returning true');\r\n            return true;\r\n        }\r\n        var accessToken = ExtractUtils_1.ExtractUtils.extractToken(token);\r\n        // AccessToken extraction would not work for future encrypted JWE tokens,\r\n        // If cannot be extracted, also return true\r\n        if (!accessToken || (accessToken && accessToken.upn && accessToken.upn.toLowerCase() === authConfig.upn.toLowerCase())) {\r\n            return true;\r\n        }\r\n        LoggingUtils_1.LoggingUtils.log('provided Upn does not match Upn extracted from access token');\r\n        return false;\r\n    };\r\n    ValidateUtils.enableUpnCheck = false;\r\n    return ValidateUtils;\r\n}());\r\nexports.ValidateUtils = ValidateUtils;\r\n\n\n//# sourceURL=webpack://BrowserAuth/./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/Utils/ValidateUtils.ts?");

/***/ }),

/***/ 0:
/*!***********************************************************************************************************************************************!*\
  !*** multi ./packages/Microsoft.Office.WebAuth.BrowserAuth/lib/api.js ./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/BrowserAuth.ts ***!
  \***********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! D:\\a\\1\\s\\src\\packages\\Microsoft.Office.WebAuth.BrowserAuth\\lib\\api.js */\"./packages/Microsoft.Office.WebAuth.BrowserAuth/lib/api.js\");\nmodule.exports = __webpack_require__(/*! D:\\a\\1\\s\\src\\packages\\Microsoft.Office.WebAuth.BrowserAuth\\scripts\\BrowserAuth.ts */\"./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/BrowserAuth.ts\");\n\n\n//# sourceURL=webpack://BrowserAuth/multi_./packages/Microsoft.Office.WebAuth.BrowserAuth/lib/api.js_./packages/Microsoft.Office.WebAuth.BrowserAuth/scripts/BrowserAuth.ts?");

/***/ })

/******/ });